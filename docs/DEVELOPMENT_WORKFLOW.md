# Development Workflow for c-project-skeleton-v2

This document outlines the recommended workflow for developing, testing, and releasing the project. The workflow leverages our Makefile targets for building, analyzing, debugging, unit testing, and eventually compiling a production build.

## 1. Setup and Environment

- **Clone the Repository:**
  Begin by cloning the repository onto your local machine.
- **Development Environment:**
  - Use VSCode (or your preferred editor) with the provided workspace settings in the `.vscode` folder.
  - Ensure you have the required tools installed: gcc/clang, make, clang-format, clang-tidy, cppcheck, Valgrind (Linux), Check (for unit testing), and any sanitizers (ASAN, TSAN, UBSAN).

- **Directory Structure:**
  Familiarize yourself with the project layout:
  - `src/`: Contains C source files.
  - `include/`: Contains header files.
  - `build/` and `bin/`: Generated by the build process.
  - `docs/`: Documentation, including this workflow.
  - `tests/`: Unit or integration tests.

## 2. Code Development

- **Writing Code:**
  - Develop new features or fix bugs in the `src/` and `include/` directories.
  - Write your unit tests using the Check framework in the `tests/` directory.
  - Adhere to the coding standards defined in our `.clang-format` (which follows Google's recommended formatting rules for C) and our strict compiler flags.

- **Code Formatting:**
  - Run `make format` frequently to ensure consistent formatting across your codebase.
  - VSCode can be configured to format on save using clang-format.

## 3. Building and Debugging

- **Debug Build:**
  - Use `make debug` to compile the project with debug flags. This builds an executable in `bin/main` with symbols and no optimization.
- **Static Analysis:**
  - Run static analysis targets such as:
    - `make clang-tidy` – for clang-tidy analysis.
    - `make cppcheck` – for additional static checks.
    - `make clang-analyze` – for Clang Static Analyzer.
    - `make dependency-check` - to identify vulnerabilities in your dependencies. Ensure the OWASP Dependency Check CLI is installed at `$HOME/dependency-check`.
- **Sanitizer Tests:**
  - Run memory sanitizers and other runtime checks:
    - `make asan` – to check for memory errors using AddressSanitizer.
    - `make lsan`, `make tsan`, and `make ubsan` – for leak detection, thread-safety, and undefined behavior, respectively.
- **Debugger:**
  - If you need to step through your code, run `make debugger` which launches your executable in gdb (or lldb on macOS).

- **Unit Testing:**
  - Run `make test` to compile and execute your unit tests using the Check framework.

## 3.5 Additional Static Analysis & Quality Tools

- **SonarQube:**
  Run `make sonar-scanner` to perform a comprehensive code quality analysis. Ensure your SonarQube instance (or Docker container) is running so that your project's metrics and issues are uploaded and visualized in the SonarQube dashboard.
- **Splint:**
  Execute `make splint` to run Splint as an alternative static analysis tool. Splint provides additional insight into potential issues, complementing the checks performed by clang-tidy, cppcheck, and the Clang Static Analyzer.
- **Facebook Infer (optional):**
  For advanced static analysis, consider using Facebook Infer. You can invoke it manually with:
  ```bash
  infer run -- make debug
  ```
  Infer may uncover issues that other tools might miss, offering another layer of code quality assurance.

## 4. Profiling and Coverage

- **LLVM Code Coverage:**
  - Use `make llvm-coverage` to generate code coverage reports. This target builds with coverage flags, runs the executable, and then processes the coverage data using LLVM tools.
- **Valgrind Tools (Linux Only):**
  - For further memory and performance profiling, use:
    - `make valgrind-memcheck`
    - `make valgrind-cachegrind`
    - `make valgrind-callgrind`
    - `make valgrind-massif`

## 5. Final Production Build

- **Release Build:**
  - When you’re ready to compile a production version, run:
    ```bash
    make release
    ```
  - This builds the project with optimization flags (`-O2`).
- **Final Testing:**
  - Perform any final testing on the release build. Optionally, run dependency checks, static analysis, or further profiling to ensure quality.

## 6. Continuous Integration and Deployment

- **Automation:**
  - The `.github` folder contains configurations for GitHub Actions. Use these workflows to automatically run your tests, static analysis, and build processes on every commit or pull request.
- **Deployment:**
  - Once your release build is validated, proceed with your deployment process as defined by your project’s needs.

## 7. Branching and Git Workflow

- **Develop Branch:**
  We maintain a `develop` branch for ongoing development. It is highly recommended to follow a structured Git workflow (e.g., GitFlow) to manage feature branches, releases, and hotfixes.
- **Forking:**
  While we recommend a structured workflow, anyone is free to fork the repository and adopt their own branching methodology.
